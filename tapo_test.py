import asyncio
import os
from datetime import datetime, timedelta
import pandas as pd
import matplotlib.pyplot as plt

from tapo import ApiClient, EnergyDataInterval
from dotenv import load_dotenv


async def main():
    load_dotenv()
    tapo_username = os.getenv("TAPO_USERNAME")
    tapo_password = os.getenv("TAPO_PASSWORD")
    solar_ip_address = "192.168.178.61"
    wasching_machine_ip_address = "192.168.178.52"

    client = ApiClient(tapo_username, tapo_password)
    device_solar = await client.p110(solar_ip_address)
    device_wasching_machine = await client.p110(wasching_machine_ip_address)

    device_info = await device_solar.get_device_info()
    print(f"Device info: {device_info.to_dict()}")
    # get energy data for all quarters until now
    # current quarter
    cur_quarter = (datetime.today().month - 1) // 3 + 1
    list_dict_energy_data_daily = []
    for i_quarter in range(1, cur_quarter + 1):
        quarter_start_month = 3 * (i_quarter - 1) + 1
        dict_energy_data_daily = (await get_energy_data_daily(device_solar, quarter_start_month)).to_dict()
        list_dict_energy_data_daily.append(dict_energy_data_daily)
    # concat dicts to one
    df_energy_consumption = []
    for i_quarter_m1, dict_energy_data in enumerate(list_dict_energy_data_daily):
        quarter_start_month = 3 * i_quarter_m1 + 1
        df_energy_consumption.append(get_date_df_from_dict(dict_energy_data, quarter_start_month))
    df_energy_consumption = pd.concat(df_energy_consumption)
    # delete dates that are in the future
    df_energy_consumption = df_energy_consumption[df_energy_consumption['Date'] <= datetime.today().strftime('%Y-%m-%d')]
    # plot energy consumption
    df_energy_consumption.plot(kind='bar', x='Date', y='Value', title='Energy consumption (daily)')
    plt.savefig('energy_consumption_daily.png')

    cur_power_solar = await device_solar.get_current_power()
    print(f"Current power solar: {cur_power_solar.to_dict()}")

    cur_power_wasching_machine = await device_wasching_machine.get_current_power()
    print(f"Current power wasching machine: {cur_power_wasching_machine.to_dict()}")
    # set date as index for df_energy_consumption
    df_energy_consumption.set_index('Date', inplace=True)
    solar_energy_generated_today = df_energy_consumption.loc[str(datetime.today().date())]['Value']
    max_solar_energy = df_energy_consumption['Value'].max()
    mean_solar_energy = compute_mean_energy_consumption(df_energy_consumption)
    saved_costs_today = compute_costs(solar_energy_generated_today / 1000)
    # sum up generated energy for the year
    saved_energy_this_year = df_energy_consumption['Value'].sum()
    saved_costs_year = compute_costs(saved_energy_this_year / 1000)
    message = (f"The energy consumed today has been {solar_energy_generated_today / 1000:.4g} kWh "
               f"which is {solar_energy_generated_today / max_solar_energy:.1%} of the maximum energy generated "
               f"this year ({max_solar_energy / 1000:.4g} kWh)."
               f"You saved {saved_costs_today:.2f} € today and {saved_costs_year:.2f} € this year. "
               f"The mean energy consumption is {mean_solar_energy:.2f} kWh.")
    print(message)
    # print(f"The energy generated by the solar today has been {dict_energy_data_daily['data'][-1]} kWh")


def compute_costs(saved_kwh):
    cost_per_kwh = 0.28
    savings = saved_kwh * cost_per_kwh
    return savings


def get_quarter_start_month(today: datetime) -> int:
    return 3 * ((today.month - 1) // 3) + 1


def compute_mean_energy_consumption(df_energy_consumption):
    # drop zeros
    df_energy_consumption = df_energy_consumption[df_energy_consumption['Value'] > 0]
    mean_energy_consumption = df_energy_consumption['Value'].mean()
    return mean_energy_consumption

async def get_energy_data_daily(device, startmonth):
    # return await device.get_energy_data(
    #     EnergyDataInterval.Daily,
    #     datetime(datetime.today().year, get_quarter_start_month(datetime.today()), 1),
    # )
    return await device.get_energy_data(
        EnergyDataInterval.Daily,
        datetime(datetime.today().year, startmonth, 1),
        datetime.today()
    )


def get_date_df_from_dict(data_dict, startmonth):

    # Calculating start date from end_timestamp and data length
    # convert local_time in format '2024-03-21T10:08:34' to datetime object
    local_time = datetime.strptime(data_dict['local_time'], '%Y-%m-%dT%H:%M:%S')
    # create datetime-object named start_date for date 2024-01-01
    start_date = datetime(local_time.year, startmonth, 1)

    # end_date = local_time
    # interval_days = data_dict['interval'] // 1440  # Assuming interval is in minutes
    # end_date = start_date + timedelta(days=(len(data_dict['data']) - 1) * interval_days)

    # Generating date range
    dates = [start_date + timedelta(days=i) for i in range(len(data_dict['data']))]
    print(dates)

    # Creating DataFrame
    df = pd.DataFrame({
        'Date': dates,
        'Value': data_dict['data']
    })

    # Formatting Date column
    df['Date'] = df['Date'].dt.strftime('%Y-%m-%d')
    return df


if __name__ == "__main__":
    asyncio.run(main())
